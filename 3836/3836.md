# Issue #3836: Inspect use of `error`

https://github.com/input-output-hk/ouroboros-network/issues/3836

We began this work by branching at `77b54c71ca67a759f82872791749fea549ee3bc7`,
committed 18 August 2023.


## Enumerating Files of Interest

Per Mark's advice, I have classified files into two tiers.

The first tier consists of files in the following packages, excluding those used
in testing within those packages:
- `ouroboros-network`
- `ouroboros-network-api`
- `ouroboros-network-protocols`
- `ouroboros-network-framework`

The second tier consists of files in the following packages, excluding those
used in testing within those packages: 
- `cardano-client`
- `cardano-ping`
- `monoidal-synchronisation`
- `network-mux`
- `ntp-client`
- `ouroboros-network-mock`
- `ouroboros-network-testing`

For the moment, we are not focusing on uses of `error` in testing files within
these packages. We consider `error` to be more plausibly useful in testing than
in production code, and its removal to be less necessary. If need be, we can
create a third tier of files consisting of those used in testing across all
packages.

Enumeration of these files is done via the included shell script, `files.sh`.
Its usage is `files.sh (1|2)`, and it prints the location of all calls to error
in the files comprising the command-line-specified tier. It finds these
locations via lightweight semantic analysis (read: `grep`).


## Tier 1

Tier 1 files contain 17 uses of `error`.

### 1: `ouroboros-network/demo/chain-sync.hs:577`
```hs
nextState [] = error "chainSyncServer: impossible"
```

The list on which `nextState` is called originates from `chainGenerator` in the
same file. `nextState` will never see an empty list because `chainGenerator`
creates an infinite list.

As one possible fix, I've replaced the error message with a more informative
one.

As another, I've lifted the `chainGenerator` result into an `Infinite`
construction, courtesy of
[`infinite-list`](https://hackage.haskell.org/package/infinite-list-0.1/docs/Data-List-Infinite.html).
If this is too much, the commit introducing it (`1189f40e`) can be reverted.


### 2: `ouroboros-network/src/Ouroboros/Network/PeerSelection/Governor/Types.hs:674`
```hs
error $ "A pick policy requested an attribute for peer address "
     ++ " which is outside of the set given to pick from"
```

This use of `error` appears in `pickPeers`, which is a "`PickPolicy` wrapper
function". `pickPeers` is provided:
- A `PeerSelectionState` containing i.a. `localRootPeers`,
  `publicRootPeers`, and `knownPeers`
- A `PickPolicy` called `pick`
- A `Set peeraddr` called `available`

A `PickPolicy` is "an action that picks a subset of elements from a [collection]
of peers". It makes this choice by examining each peer in this collection and
examining them via several functions (generally of the shape `peeraddr -> _`) it
is provided.

`pickPeers` provides `pick`, its `PickPolicy`, with functions of its own
creation. Those functions check their input peer for membership in
`localRootPeers`, `publicRootPeers`, and `knownPeers`, and trigger the error if
the peer is not found in `knownPeers`, but `pick` will only ever apply them to
peers in `available`. Therefore, the error may be triggered if a peer in
`available` is not in `knownPeers` (i.e. if `available` is partially disjoint
from `knownPeers`).

In practice, `available` appears to be constructed from the various peer
collections in a `PeerSelectionState`, whose invariant (as described in
`assertPeerSelectionState` in this same module) ensures that `knownPeers` is a
superset of all other peer sets, so this error is quite unlikely to be triggered
as long as any extant `PeerSelectionState` adheres to its invariant.

I've added documentation at this `error` site of the rationale I've derived, and
have included a reference to the invariant-documenting function at the
declaration site of `PeerSelectionState`.

I've also added a precondition that checks whether `available` is a subset of
`knownPeers`. This may offer a poor utility to expense ratio in practice, and
I'd welcome input and discussion on this change.

**Fix: document**
#fixed
**Fix: precondition**
#fixed

#input-desired


### 3: `ouroboros-network/src/Ouroboros/Network/PeerSelection/Governor.hs:544`
```hs
-- impossible since guardedDecisions always has something to wait for
error "peerSelectionGovernorLoop: impossible: nothing to do"
```

The comment is correct, but I will elaborate on why.

`guardedDecisions`'s result is of type `Guarded`:
```hs
data Guarded m a =
    GuardedSkip !(Maybe (Min Time))
  | Guarded' !(Maybe (Min Time)) (FirstToFinish m a)
```

`Guarded` has a `Semigroup` instance:
```hs
instance Alternative m => Semigroup (Guarded m a) where
  Guarded'    ta a <> Guarded'    tb b = Guarded'    (ta <> tb) (a <> b)
  Guarded'    ta a <> GuardedSkip tb   = Guarded'    (ta <> tb)  a
  GuardedSkip ta   <> Guarded'    tb b = Guarded'    (ta <> tb)  b
  GuardedSkip ta   <> GuardedSkip tb   = GuardedSkip (ta <> tb)
```

Note that the presence of any `Guarded'`-constructed value in a `<>` operation
dominates - that is, will guarantee a `Guarded'`-constructed value. 

Here, "something to wait for" means "a `Guarded` value constructed via
`Guarded'` rather than `GuardedSkip`. `guardedDecisions` constructs a `Guarded`
value by concatenating (via `<>`) several `Guarded` values. At least one of
these values is always constructed via `Guarded'`:
`Ouroboros.Network.PeerSelection.Governor.Monitor.connections`. (In fact,
several others are as well.) The presence of this value guarantees that
`guardedDecisions` produces a `Guarded'` value - i.e., "something to wait for".

Either way, I have pushed the error down to `guardedDecisions`, by exposing an
API to its behavior that promises a non-`GuardedSkip` value.


### 4: `ouroboros-network/src/Ouroboros/Network/PeerSelection/RootPeersDNS.hs:217`
```hs
Nothing  -> error "localRootPeersProvider: impossible happened"
```

The error is triggered only if `waitAnyCatchSTM` were to disobey its contract.

[`waitAnyCatchSTM`](https://hackage.haskell.org/package/async-2.2.4/docs/Control-Concurrent-Async.html#v:waitAnyCatchSTM):
> A version of `waitAnyCatch` that can be used inside an STM transaction".


[`waitAnyCatch`](https://hackage.haskell.org/package/async-2.2.4/docs/Control-Concurrent-Async.html#v:waitAnyCatch) :
> Wait for any of the supplied asynchronous operations to complete. The value
> returned is a pair of the `Async` that completed, and the result that would be
> returned by `wait` on that `Async`.
>
> If multiple `Async`s complete or have completed, then the value returned
> corresponds to the first completed `Async` in the list.

`waitAnyCatchSTM`, then, will always yield an asynchronous action that was part
of the original list, so not finding one should necessitate a `panic`. (This
analysis assumes a coherent instance of `Eq (Async m Void)`, one that will
"correctly" compare an action as equal with itself.)

Because this pattern is somewhat inverted, in that threads are expected to throw
exceptions rather than run to completion, it's difficult to factor out the use
of `error` here, even though it seems like it ought to be possible with a
judicious application of `zip` to associate the domains with their async
results.

At any rate, a better error message is warranted, so I've changed it to
"localRootPeersProvider: `waitAnyCatchSTM` yielded an action not present in its
original list".

Additionally, the immediate context of this error could be modified to save up
to a single traversal of the action/domain lists:
```hs
-- Current: traverse `as` then traverse `domains`
let domain :: DomainAccessPoint
    domain = case a `elemIndex` as of
      Nothing  -> error "..."
      Just idx -> case domains !! idx of x -> x

-- Proposed: zip and traverse `as` and `domains` together
let domain :: DomainAccessPoint
    domain = case lookup a (zip as domains) of
      Nothing -> error "..."
      Just d -> d
```

**Fix: document**
#fixed

#proposed-improvement


### 5: `ouroboros-network/src/Ouroboros/Network/PeerSelection/PeerMetric.hs:387`
```hs
Nothing -> error "impossible empty pq"
```

The surrounding code documents well the impossibility of this error. The code
inserts an element into an `IntPSQ`, then gets the minimum value from the new
`IntPSQ`. The new queue is guaranteed not to be empty, by `IntPSQ.insert`'s
contract, so there will always be a minimum to find.

**Fix: none**
#fixed


### 6: `ouroboros-network/src/Ouroboros/Network/BlockFetch/ClientRegistry.hs:301`
```hs
unless ok $ error "setFetchClientContext: called more than once"
```

The surrounding code tries to set a `StrictTMVar`, via `tryPutTMVar`, and
triggers this error if the operation fails, which it does iff the `StrictTMVar`
is already full. I believe this error is not impossible to trigger, but instead
represents a failure of program logic - accidentaly resetting some state instead
of initializing it from scratch - severe enough to warrant program termination.

I say "I believe" because the surrounding function (`setFetchClientContext`) is
undocumented. It should probably have some commentary attesting to this logic
and the rationale for this error.

**Fix: document**
#unfixed

#input-desired


### 7: `ouroboros-network/src/Ouroboros/Network/Diffusion/P2P.hs:296`
```hs
error ("socketAddressType: unexpected address " ++ show addr)
```

The error is triggered iff the surrounding function, `socketAddressType` is
called on a `SockAddr` that isn't `SockAddrInet`- or
`SockAddrInet6`-constructed. I presume these applications expect IP sockets and
that program termination is warranted if they see something else, so this error
is logically appropriate.

However, in addition to being partial via `error`, `socketAddressType` is also
partial via `Maybe` (`SockAddr -> Maybe AddressType`), which seems to be to
match a pattern of other record fields (`diNtnAddressType`, `cmAddressType`,
perhaps inter alia) being similarly partial. I hesitantly assume that the
program logic would change if the `error` call were replaced with a
`Nothing`-constructed result, but
- if that is the case, then
  - there should probably be documentation to that effect on this function to
    warn future maintainers from accidentally making such a change, or
  - the function should be made total in type (`SockAddr -> AddressType`) and
    composed with `Just` at use sites
- if that **isn't** the case, then the error should be replaced with `Nothing`

Regardless, for robustness's sake, I have modified `socketAddressType` to
explicitly match on the remaining `SockAddr` constructor.

**Fix: uncertain**
#unfixed
**Fix: refactor**
#fixed

#input-desired


### 8: `ouroboros-network/src/Ouroboros/Network/KeepAlive.hs:103`
```hs
-- 'decisionSTM' above cannot return 'Quiesce'
Quiesce   -> error "keepAlive: impossible happened"
```

The comment is correct, `decisionSTM` only returns `Terminate` or `Continue`.
The message has been changed to reflect the name of the surrounding function,
`keepAliveClient`.

**Fix: message**
#fixed


### 9: `ouroboros-network/src/Ouroboros/Network/TxSubmission/Outbound.hs:142`
```hs
(Nothing, TokNonBlocking) -> error "txSubmissionOutbound: impossible happend!"
```

The surrounding context makes clear that this error is impossible. The matched
variables are `mbtxs` and `blocking`, and `mbtxs` is initialized based on the
state of `blocking`. If `blocking` is `TokNonBlocking`, the only possible
constructor for `mbtxs` is `Just`.

I've refactored the code to eliminate this error by lifting more functionality
into the pattern-match on `blocking`. I've tried to maintain the original
strictness of the expression, but this could use a second set of eyes to make
sure the strictness semantics haven't changed.

**Fix: refactor**
#fixed

#input-desired


### 10: `ouroboros-network/src/Ouroboros/Network/TxSubmission/Outbound.hs:163`
```hs
Nothing -> error "txSubmissionOutbound: empty transaction's list"
-- Assert txs is non-empty: we blocked until txs was non-null,
-- and we know reqNo > 0, hence take reqNo txs is non-null.
```

The accompanying comment explains well the impossibility of this code path. No
semantic changes are required, though I have bracketed the expression `take
reqNo txs` for clarity.

**Fix: document**
#fixed


### 11: `ouroboros-network-api/src/Ouroboros/Network/PeerSelection/PeerSharing.hs:91`
```hs
encodeRemoteAddress (SockAddrUnix _) = error "Should never be encoding a SockAddrUnix!"
```

This error is similar to #7, above - the code expects and supports IP sockets,
and does not expect or support Unix sockets. If the error logic underpinning #7
applies here, triggering this error would be the result of significant
misconfiguration, and program termination would be warranted.

**Fix: none**
#fixed

#input-desired


### 12: `ouroboros-network-api/src/Ouroboros/Network/AnchoredSeq.hs:810`
```hs
fromMaybe (error "could not join sequences") $
```

The enclosing function exposes a total/irrefutable interface for `join`. It
passes an always-passing predicate to `join`, which guarantees a
`Just`-constructed result from `join`, so the error will never trigger. The
function is documented to describe why this irrefutability is sound.

One option to eliminate this error entirely would be to create an
actually-total/irrefutable version of `join` - i.e., one that does not do
`join`'s normal check for compatibility between sequences. This could be
locally-scoped or defined at top level - though I would *not* expect to export
it from the module. I tend to think this would be a bit of a footgun, but any
thoughts on the wisdom of this change would be welcomed.

**Fix: none**
#fixed

#input-desired


### 13: `ouroboros-network-api/src/Ouroboros/Network/NodeToNode/Version.hs:174`
```hs
_ -> error "decodeTerm: impossible happened!",
```

The error is triggered when a `peerSharing` value, in a context in which it is
guarded to be between 0 and 2 (`| ..., peerSharing >= 0, peerSharing <= 2`),
pattern-matches to a number other than 0, 1, or 2. Failure of the primary guard
already triggers failure via `Left`, so I've eliminated the mention of `error`
by reorganized the pattern-matching while preserving the existing circumstances
in which failure via `Left` is indicated.

**Fix: refactor**
#fixed


### 14: `ouroboros-network-api/src/Ouroboros/Network/AnchoredFragment.hs:165`
```hs
anchorFromPoint GenesisPoint _     = error "anchorFromPoint: genesis point"
```

I don't fully understand, logically, why calling `anchorFromPoint` on
`GenesisPoint` warrants an error. It seems like the natural result would be
`AnchorGenesis`, an `Anchor` constructor seemingly for this purpose, rather than
an error. Such a change would bring `anchorFromPoint` and `anchorToPoint` closer
to being logical inverses of one another, if this is desirable.

I note that this function is exported but does not appear to be used elsewhere
within the IOG org (per an org-wide Github search). Perhaps it could be marked
deprecated and/or removed?

**Fix: uncertain**
#unfixed

#input-desired


### 15: `ouroboros-network-framework/src/Ouroboros/Network/Protocol/Handshake/Version.hs:73`
```hs
[] -> error "foldMapVersions: precondition violated"
```

This error appears in `foldMapVersions`, which converts a collection of things
into a collection of `Version`s (represented as a `Versions` value). The
precondition in question is that the collection of things be nonempty. The
rationale for this precondition is not obvious - I do not immediately see why it
is erroneous to have an empty `Versions` value, which can be constructed
manually based on this module's exports. This module might benefit from
documentation of that rationale, and/or restriction of its exports to prevent
manual construction of empty `Versions` values.

Separately, `foldMapVersions` could be modified to save a `toList` conversion:
```hs
-- Existing:
foldMapVersions f fx = case toList fx of
    [] -> error "foldMapVersions: precondition violated"
    xs -> foldl1 (<>) (map f xs)

-- Proposed:
foldMapVersions f fx
  | null fx = error "foldMapVersions: precondition violated"
  | otherwise = Versions (foldMap' f' fx)
  where
    f' = getVersions . f
```

This would better fit with `Foldable` idioms - `toList` advises: "[i]f the
entire list is intended to be reduced via a fold, just fold the structure
directly bypassing the list." This change would affect strictness: `foldMap'` is
left-associative and strict in its accumulator, while `foldl1` is
left-associative but lazy in its accumulator. In principle, this should be a net
gain for efficiency, since lazy left-folds are generally undesirable.

**Fix: document**
#unfixed

#input-desired

#proposed-improvement


### 16: `ouroboros-network-framework/src/Ouroboros/Network/Snocket.hs:543`
```hs
toLocalAddress _                   = error "localSnocket.toLocalAddr: impossible happened"
```

This error is triggered if a non-Unix is encountered in the process of creating
a local snocket. Local snockets rely on Unix sockets or named pipes, and cannot
be constructed from IP sockets. The error seems justified.

I've filled out the function clauses to explicitly match on other socket
constructors, for robustness's sake and to improve the error messages.

**Fix: message**
#fixed


### 17: `ouroboros-network-framework/src/Ouroboros/Network/Channel.hs:231`
```hs
if full then error failureMsg
```

This error is triggered when trying to write to a full buffer. This behavior is
intentional: the enclosing function makes its potentially partial semantics
clear in its documentation, and declares itself "primarily useful for testing
protocols." No changes are warranted.

**Fix: none**
#fixed


## Tier 2

Tier 2 files contain 11 uses of `error`.

### 1: `cardano-ping/src/Cardano/Network/Ping.hs:183`
```hs
handshakeReqEnc [] _ = error "null version list"
```

The error is triggered when `handshakeReqEnc` is provided an empty list of
`NodeVersion` - but its only caller, `handshakeReq`, also guards against
providing an empty list. I've changed `handshakeReqEnc` to expect a `NonEmpty
NodeVersion` to eliminate the error.

**Fix: refactor**
#fixed


### 2: `network-mux/src/Network/Mux/DeltaQ/TraceStats.hs:37`
```hs
Nothing -> error "step: missing referenceTimePoint"
```

The error is triggered when the `referenceTimePoint` is `Nothing` - but this
eventuality is handled in a prior function guard, so the error is never
triggered. More careful pattern-matching eliminates the call to `error`.

**Fix: refactor**
#fixed


### 3: `network-mux/src/Network/Mux/DeltaQ/TraceStats.hs:253`
```hs
= error "Infeasible sampleInterval"
```

This error is triggered when a developer tries to provide an unsuitable sample
interval. The existing interval is suitable, so I assume this variable is
somewhat volatile during some development process. The suitability of the
provided interval can be determined statically, so I've lifted this computation
to be compile-time via Template Haskell, so that the package fails to compile
with an unsuitable interval.

TH is polarizing, I realize, so I would be happy to discuss this in greater
detail and revert it if there's no appetite for such a change.

**Fix: refactor**
#fixed

#input-desired


### 4: `network-mux/src/Network/Mux/Ingress.hs:185`
```hs
Nothing -> error ("setupDispatchTable: missing " ++ show miniProtocolNum)
```

The error occurs if, in the building of an array (`ptclArray`), an intermediate
array (`pnumArray`) resolves an index (`miniProtocolNum`) to an "empty"
(represented as `Nothing`) slot.

`pnumArray` is constructed such that every `miniProtocolNum` in `ptcls` maps to
a `Just`-constructed slot. `ptclArray` is constructed by using every
`miniProtocolNum` in `ptcls` to index `pnumArray`, and will trigger this error
on encountering `Nothing` as a result of that indexing. Therefore, by
construction, the error will never trigger.

Leveraging this principle, I've reworked the list comprehension to extract the
`Just`-constructed value required using a view pattern. The semantics of this
are now slightly different: if `pnumArray` fails to index, `ptclArray` will
silently skip the offending element instead of loudly failing. I've included
commentary to this effect.

**Fix: refactor**
#fixed


### 5: `ntp-client/src/Network/NTP/Client.hs:105`
```hs
Right NtpSyncPending -> error "ntpClientThread: impossible happened"
```

`ntpClientThread` calls `ntpQuery` and decomposes its `NtpStatus` result. A
`NtpSyncPending`-constructed value result triggers this error - but `ntpQuery`
will only ever produce `NtpSyncUnavailable` or `NtpDrift` values.

I've created a new abstraction for NTP statuses that can only represent the two
"completed" versions of an `NtpStatus`, and made `ntpQuery` yield that instead,
so the match for the impossible case no longer exists.

**Fix: refactor**
#fixed


### 6: `ouroboros-network-mock/src/Ouroboros/Network/Mock/ConcreteBlock.hs:222`
```hs
partialField n = error ("mkPartialBlock: you didn't fill in field " ++ n)
```


### 7: `ouroboros-network-mock/src/Ouroboros/Network/Mock/Chain.hs:235`
```hs
go _ = error "successorBlock: point not on chain"
```

The enclosing function, `successorBlock`, tries to find the successor block of a
given point on a given chain. At the moment, this error is triggered iff the
point is not on the chain.

All callers already check point membership on the chain, via `pointOnChain`,
before calling this function. Additionally, the QuickCheck test of this
function's behavior is structured as an implication, where use of
`successorBlock` is guarded by a positive result from `pointOnChain`. I
therefore claim that an idiom has emerged: using `successorBlock` to find the
successor of a nonexistent point is considered undefined behavior. I propose to
codify this idiom in the function's contract, then redefine the undefined
behavior to be `Nothing`, a non-`error` result that happens to inhabit the
function's return type.

**Fix: refactor**
#fixed

#input-desired


### 8/9: `ouroboros-network-testing/src/Ouroboros/Network/Testing/Data/Script.hs:221/223`
```hs
= error "interpretPickScript: given empty map to pick from"
-- ...
= error "interpretPickScript: given invalid pickNum"
```

`interpretPickScript` is used to create `PickPolicy`s to initialize a
`PeerSelectionPolicy`. Its two errors both ensure the same precondition that
`Ouroboros.Network.PeerSelection.Governor.Types.pickPeers` ensures when
executing a `PickPolicy` - that there are peers available to pick from, and that
we are picking more than zero of them.

It's my understanding that `PickPolicy`s aren't called directly, but are always
invoked via `pickPeers`. If this is true, then we can remove these error checks
from `interpretPickScript` entirely, trusting that the checks in `pickPeers`
will catch the same failures. If this isn't true, then we could either leave
this code as-is or change it to the `assert` style favored by `pickPeers`.

**Fix: uncertain**
#unfixed

#input-desired


### 10/11: `ouroboros-network-testing/src/Ouroboros/Network/Testing/Data/Signal.hs:251/305`
```hs
linger = error "TODO: Signal.linger"
-- ...
until _ = error "TODO: Signal.until"
```

These are stubs of unimplemented functions. As far as I can tell, these
functions are unused.

**Fix: implement**
#unfixed


